import pandas as pd
import numpy as np
import glob
import math
import matplotlib.pyplot as plt
import seaborn as sns


a = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/17Q3-pt1.csv", low_memory=False)
b = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/17Q3-pt2.csv", low_memory=False)
c = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/17Q4-pt1.csv", low_memory=False)
d = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/17Q4-pt2.csv", low_memory=False)
e = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/18Q1-pt1.csv", low_memory=False)
f = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/18Q1-pt2.csv", low_memory=False)
g = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/18Q2-pt1.csv", low_memory=False)
h = pd.read_csv("/Users/ericchiyembekeza/Desktop/Data/18Q2-pt2.csv", low_memory=False)
frames = [a,b,c,d,e,f,g,h]
df = pd.concat(frames, sort=False)
df.head()

#df = pd.concat([pd.read_csv(f, dtype="category") for f in glob.glob('/Users/ericchiyembekeza/Desktop/Data/*.csv')], ignore_index = True, sort=False)
#df.columns
#df['ATTEN_PHYN']
useless_cols = ['TYPE_SERV', 'SERV_LOC','EVALCODE1', 'EVALCODE2', 'EVALCODE3', 'EVALCODE4','EVALCODE5', 'OTHCPT1', 'OTHCPT2', 'OTHCPT3', 'OTHCPT4', 'OTHCPT5','OTHCPT6', 'OTHCPT7', 'OTHCPT8', 'OTHCPT9', 'OTHCPT10', 'OTHCPT11','OTHCPT12','OTHCPT13', 'OTHCPT14', 'OTHCPT15', 'OTHCPT16', 'OTHCPT17','OTHCPT18', 'OTHCPT19', 'OTHCPT20', 'OTHCPT21', 'OTHCPT22', 'OTHCPT23','OTHCPT24', 'OTHCPT25', 'OTHCPT26', 'OTHCPT27', 'OTHCPT28', 'OTHCPT29','OTHCPT30','PRINDIAG','OTHDIAG1','OTHDIAG2','OTHDIAG3', 'OTHDIAG4','OTHDIAG5', 'OTHDIAG6', 'OTHDIAG7', 'OTHDIAG8', 'OTHDIAG9', 'ECMORB1','ECMORB2', 'ECMORB3', 'PRINPROC', 'OTHPROC1', 'OTHPROC2', 'OTHPROC3','OTHPROC4']
df = df.drop(columns=useless_cols)
df.describe()
df['ETHNICITY'].unique()
df['ETHNICITY'] = df['ETHNICITY'].map(lambda x: x.lstrip('E'))
def wrangle(X):
    def is_opioid_dx(opioid_dx):
        if opioid_dx in ['F11.10','F11.120','F11.121','F11.122','F11.129','F11.14','F11.150','F11.151','F11.159','F11.181','F11.182','F11.188',
        'F11.19','F11.20','F11.220','F11.221','F11.222','F11.229','F11.23','F11.24','F11.250','F11.251','F11.259','F11.281','F11.282','F11.288',
        'F11.29','F11.90','F11.920','F11.921','F11.922','F11.929','F11.93','F11.94','F11.950','F11.951','F11.959','F11.981','F11.982','F11.988',
        'F11.99','T40.0X1A','T40.0X1D','T40.0X1S','T40.0X4A','T40.0X4D','T40.0X4S','T40.0X5A','T40.0X5D','T40.0X5S','T40.1X1A','T40.1X1D',
        'T40.1X1S','T40.1X4A','T40.1X4D','T40.1X4S','T40.2X1A','T40.2X1D','T40.2X1S','T40.2X4A','T40.2X4D','T40.2X4S','T40.2X5A','T40.2X5D',
        'T40.2X5S','T40.3X1A','T40.3X1D','T40.3X1S','T40.3X4A','T40.3X4D','T40.3X4S','T40.3X5A','T40.3X5D','T40.3X5S','T40.4X1A','T40.4X1D',
        'T40.4X1S','T40.4X4A','T40.4X4D','T40.4X4S','T40.4X5A','T40.4X5D','T40.4X5S','T40.601A','T40.601D','T40.601S','T40.604A','T40.604D',
        'T40.604S','T40.605A','T40.605D','T40.605S','T40.691A','T40.691D','T40.691S','T40.694A','T40.694D','T40.694S','T40.695A','T40.695D',
        'T40.695S','T40.0X2A','T40.0X2D','T40.0X2S','T40.0X3A','T40.0X3D','T40.0X3S','T40.1X2A','T40.1X2D','T40.1X2S','T40.1X3A','T40.1X3D',
        'T40.1X3S','T40.2X2A','T40.2X2D','T40.2X2S','T40.2X3A','T40.2X3D','T40.2X3S','T40.3X2A','T40.3X2D','T40.3X2S','T40.3X3A','T40.3X3D',
        'T40.3X3S','T40.4X2A','T40.4X2D','T40.4X2S','T40.4X3A','T40.4X3D','T40.4X3S','T40.602A','T40.602D','T40.602S','T40.603A','T40.603D',
        'T40.603S','T40.692A','T40.692D','T40.692S','T40.693A','T40.693D','T40.693S']:
            return 1
        else:
            return 0
    X['REASON_CDE'] = X['REASON_CDE'].apply(is_opioid_dx).astype('int32')
    def is_night(arrtime):
        arrtime_int = int(arrtime)
        if ((arrtime_int >= 0) & (arrtime_int < 8)):
            return 1
        elif ((arrtime_int >= 20) & (arrtime_int < 23)):
            return 1
        else:
            return 0
    X['HR_ARRIVAL'] = X['HR_ARRIVAL'].apply(is_night).astype('int32')
    return X
wrangle(df)
def is_sex(sex):
    if sex is 'M':
        return 1
    else:
        return 0

df['SEX'] = df['SEX'].apply(is_sex).astype(int)
df['SEX'].unique()
df['REASON_CDE'].unique()
df['HR_ARRIVAL'].unique()
from sklearn.model_selection import train_test_split
trainval, test = train_test_split(df, random_state=42)
train, val = train_test_split(trainval, random_state=42)

train.shape
val.shape
test.shape


target = 'REASON_CDE'
X_train = train.drop(columns=target)
X_val = val.drop(columns=target)
X_test = test.drop(columns=target)
y_train = train[target]
y_val = val[target]
y_train_log = np.log1p(y_train)
y_val_log = np.log1p(y_val)


import category_encoders as ce
from xgboost import XGBRegressor
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
pipeline = make_pipeline(
    ce.OrdinalEncoder(),
    XGBRegressor(n_estimators=100, random_state=42, n_jobs=-1))

encoder = ce.OrdinalEncoder()
X_train_encoded = encoder.fit_transform(X_train)
X_val_encoded = encoder.transform(X_val)
eval_set = [(X_train_encoded, y_train),
            (X_val_encoded, y_val)]
model = XGBRegressor(n_estimators=100, n_jobs=-1)
model.fit(X_train_encoded, y_train, eval_set=eval_set, eval_metric='rmse', early_stopping_rounds=8)
y_pred = model.predict(X_val_encoded)
print('Validation Error', rmse(y_val, y_pred))



%matplotlib inline
import matplotlib.pyplot as plt

results = model.evals_result()
train_rmse = results['validation_0']['rmse']
val_rmse = results['validation_1']['rmse']
epoch = range(len(train_rmse))
plt.plot(epoch, train_rmse, label='Train')
plt.plot(epoch, val_rmse, label='Validation')
plt.ylim(0.15,0.35)
plt.legend();






from scipy.stats import randint, uniform
from sklearn.model_selection import RandomizedSearchCV

param_distributions = {
    'randomforestregressor__n_estimators': randint(50, 500),
    'randomforestregressor__max_features': uniform(),
    'randomforestregressor__min_samples_leaf': [1, 10, 100]}

search = RandomizedSearchCV(
    pipeline,
    param_distributions = param_distributions,
    n_iter = 100,
    cv = 10,
    scoring = 'neg_mean_squared_error',
    return_train_score = True,
    n_jobs = -1)

search.fit(x_train, y_train_log, groups=groups)
print('Best hyperparameters', search.best_params_)
print('Cross-validation RMSLE', np.sqrt(-search.best_score_))
